#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#define RAYTRACING

#include "common.glsl"
#include "brdf.glsl"

layout(location = 0) rayPayloadEXT ReflectionPayload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 0, binding = 3, rgba32f) uniform image2D resultImage;
layout (set = 0, binding = 4, rgba32f) uniform image2D resultNormalImage;

layout(set = 1, binding = 0) uniform _CameraBuffer { GPUCameraData cameraData; };

layout(set = 3, binding = 0) uniform sampler2D gbufferAlbedoMetallic;
layout(set = 3, binding = 1) uniform sampler2D gbufferNormalMotion;
layout(set = 3, binding = 2) uniform sampler2D gbufferRoughnessDepthCurvatureMaterial;
layout(set = 3, binding = 3) uniform sampler2D gbufferUV;
layout(set = 3, binding = 4) uniform sampler2D gbufferDepth;

layout(std140, set = 5, binding = 0) readonly buffer MaterialBuffer{ GPUBasicMaterialData materials[]; };


uint wang_hash(inout uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float random_float(inout uint state)
{
    return (wang_hash(state) & 0xFFFFFF) / 16777216.0f;
}

float random_float_between(inout uint state, float min, float max) {
    return min + (max - min) * random_float(state);
}

void main()
{
	const ivec2 size = textureSize(gbufferAlbedoMetallic, 0);
	ivec2 pixel = ivec2(gl_LaunchIDEXT.xy);
	const vec2 pixelCenter = vec2(pixel) + vec2(0.5);
    const vec2 texCoord = pixelCenter / vec2(size);

	float depth = texelFetch(gbufferDepth, pixel, 0).r;
	vec3 worldPos = world_position_from_depth(texCoord, depth, cameraData.viewprojInverse) / 0.3;
	float metallic = texelFetch(gbufferAlbedoMetallic, pixel, 0).w;
	float roughness = texelFetch(gbufferRoughnessDepthCurvatureMaterial, pixel, 0).r;
	int material = int(texelFetch(gbufferRoughnessDepthCurvatureMaterial, pixel, 0).w);
	float linearDepth = texelFetch(gbufferRoughnessDepthCurvatureMaterial, pixel, 0).g;
	vec3 normal = octohedral_to_direction(texelFetch(gbufferNormalMotion, pixel, 0).rg);

	vec3 view = normalize(cameraData.cameraPos.xyz / 0.3 - worldPos.xyz);
    vec3 direction = reflect(-view, normal);

	if(material >= 0 ) {
		uint rayFlags = gl_RayFlagsOpaqueEXT;
		uint cullMask = 0xff;
		float tmin = 0.0001;
		float tmax = 100000.0;

		vec4 totalColor = vec4(0);
		if(cameraData.useStochasticSpecular == 1) {
			uint random_state = ((gl_LaunchIDEXT.x) * 1973 + 9277  * gl_LaunchIDEXT.y + cameraData.frameCount * 26699) | 1;

			int sampleCount = 1;
			for(int i = 0; i < sampleCount; i++) {
				vec4 Wh_pdf = importance_sample_ggx(vec2(random_float_between(random_state, 0, 1), random_float_between(random_state, 0, 1)), normal, roughness);
				float pdf = Wh_pdf.w;
				direction = reflect(-view, Wh_pdf.xyz);

				traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, worldPos + normal * 0.1, tmin, direction, tmax, 0);

				totalColor += vec4(payload.color, payload.hitDistance);
			}
			totalColor /= sampleCount;
			totalColor = mix(totalColor, imageLoad(resultImage, pixel), float(cameraData.frameCount) / float(cameraData.frameCount + 1));
		}
		else {
			traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, worldPos + normal * 0.1, tmin, direction, tmax, 0);
			totalColor = vec4(payload.color, payload.hitDistance);
			//traceRayEXT(topLevelAS, rayFlags, cullMask, 0, 0, 0, worldPos + normal * 0.1, tmin, reflect(-view, normal), tmax, 0);
			imageStore(resultNormalImage, pixel, vec4(normal, linearDepth));
		}
		imageStore(resultImage, pixel, totalColor);
	}
	else {
		imageStore(resultImage, pixel, vec4(0, 0, 0, -1));
		imageStore(resultNormalImage, pixel, vec4(vec3(0), -1));
	}
}