#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require

#include "common.glsl"

layout (local_size_x = 256) in;

layout(set = 0, binding = 0) uniform _Config { GIConfig config; };
layout(std140, set = 0, binding = 1) readonly buffer _InputBuffer1 { GPUProbeRaycastResult probeRaycasts[]; };
layout(std430, set = 0, binding = 2) readonly buffer _InputBuffer2 { vec4 probeBasis[]; };
layout(std140, set = 0, binding = 3) buffer _TempBuffer { vec4 tempCalculation[]; };
layout(std140, set = 0, binding = 4) buffer _OutputBuffer { vec4 outColors[]; };
layout(set = 0, binding = 5) uniform sampler2D lightmap;

layout(std140,set = 1, binding = 0) readonly buffer _ObjectBuffer { GPUObjectData objects[]; };
layout(std140,set = 2, binding = 0) readonly buffer _MaterialBuffer { GPUBasicMaterialData materials[]; };
layout(set = 3, binding = 0) uniform sampler2D[] textures;

float SH00(const vec3 d) {
  return 0.282095;
}

float SH1n1(const vec3 d) {
  return 0.488603 * d.y;
}

float SH10(const vec3 d) {
  return 0.488603 * d.z;
}

float SH1p1(const vec3 d) {
  return 0.488603 * d.x;
}

float SH2n2(const vec3 d) {
  return 1.092548 * d.x * d.y;
}

float SH2n1(const vec3 d) {
  return 1.092548 * d.y * d.z;
}

float SH20(const vec3 d) {
  return 0.315392 * (3.0 * d.z * d.z - 1);
}

float SH2p1(const vec3 d) {
  return 1.092548 * d.x * d.z;
}

float SH2p2(const vec3 d) {
  return 0.546274 * (d.x * d.x - d.y * d.y);
}

void main()
{
	uint gID = gl_GlobalInvocationID.x;

	if(gID < config.probeCount * config.rayCount) {
		vec4 color = vec4(1);
		if(probeRaycasts[gID].objectId != -1) {
			color = texture(lightmap, probeRaycasts[gID].lightmapUv / config.lightmapInputSize).rgba;

			int materialId = objects[probeRaycasts[gID].objectId].material_id;

			if(materials[materialId].texture > -1) {
				color *= vec4(texture(textures[materials[materialId].texture], probeRaycasts[gID].texUv).xyz, 1.0);
			}
			else {
				color *= vec4(materials[materialId].base_color.xyz, 1.0);
			}
		}
		else {
			//sample from skybox?
		}
		
		vec3 direction = normalize(vec3(probeRaycasts[gID].direction));
		tempCalculation[gID * config.basisFunctionCount + 0] = 4 * 3.14159265359 * 1/8000 * SH00(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 1] = 4 * 3.14159265359 * 1/8000 * SH1n1(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 2] = 4 * 3.14159265359 * 1/8000 * SH10(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 3] = 4 * 3.14159265359 * 1/8000 * SH1p1(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 4] = 4 * 3.14159265359 * 1/8000 * SH2n2(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 5] = 4 * 3.14159265359 * 1/8000 * SH2n1(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 6] = 4 * 3.14159265359 * 1/8000 * SH20(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 7] = 4 * 3.14159265359 * 1/8000 * SH2p1(direction) * color;
		tempCalculation[gID * config.basisFunctionCount + 8] = 4 * 3.14159265359 * 1/8000 * SH2p2(direction) * color;
	}

    memoryBarrier();
    barrier();

	//not sure below computation is correct, somehow control it
	if(gID < config.probeCount * config.basisFunctionCount) {
		outColors[gID] = vec4(0);
		uint probe = gID / config.basisFunctionCount;
		uint basis = gID % config.basisFunctionCount;

		for(int j = 0; j < config.rayCount; j++) {
			outColors[gID] += tempCalculation[probe * config.basisFunctionCount * config.rayCount + j * config.basisFunctionCount + basis];
		}
	}
}

/*
TODO
Inputs:
	- Lightmap texture
	- Probe Raycast Results
	- Probe Raycast Basis functions
Calculation:
	- For each probe raycast result, get the corresponding pixel color in lightmap texture
	- Multiply that value with basis functions of the corresponding probe and rayPayloadEXT
	- For each probe, average that value (i.e. divide to number of rays)
Output:
	- (probe count) * (basis function count) vec3/vec4 colors
*/

