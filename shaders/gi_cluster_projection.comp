#version 460
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_debug_printf : enable

#include "common.glsl"

layout (local_size_x = 256) in;

layout(set = 0, binding = 0) uniform _Config { GIConfig config; };
layout(std140, set = 0, binding = 1) readonly buffer _InputBuffer1 { vec4 probeRelightColors[]; };
layout(std430, set = 0, binding = 2) readonly buffer _InputBuffer2 { float clusterProjectionMatrices[]; };
layout(set = 0, binding = 3) buffer _OutputBuffer { vec4 outColors[]; };

void main()
{
	uint gID = gl_GlobalInvocationID.x;

	if(gID < config.clusterCount) {
		for(int c = 0; c < config.pcaCoefficient; c++) {
			outColors[gID * config.pcaCoefficient + c] = vec4(0.0);
		}
		int total = config.probeCount * config.basisFunctionCount;
		
		for(int i = 0; i < total; i++) {
			vec4 color = probeRelightColors[i];
			for(int c = 0; c < config.pcaCoefficient; c++) {
				outColors[gID * config.pcaCoefficient + c] += color * clusterProjectionMatrices[total * config.pcaCoefficient * gID + c * total + i ];
			}
		}
	}
}
/*
TODO
Inputs:
	- Result from gi_probe_projection
		(probe count) * (basis function count) vec3/vec4 colors
	- Cluster projection matrices
		1000s of 32 * ((probe count) * (basis function count)))
Calculation:
	- Matrix multiplication for each cluster
Output: 
	- 32 * 1 matrix for each cluster (1000s)
*/