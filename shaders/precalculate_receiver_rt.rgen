#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_debug_printf : enable

#define RAYTRACING

#include "common.glsl"

layout(location = 0) rayPayloadEXT GPUHitPayload payload;

layout(set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout(set = 0, binding = 1) uniform _SceneDesc { GPUSceneDesc sceneDesc; };
layout(std140, set = 0, binding = 2) readonly buffer _MeshInfo { GPUMeshInfo meshInfos[]; };
layout(std140, set = 0, binding = 3) readonly buffer _ProbeLocations { vec4 probeLocations[]; };
layout(std140, set = 0, binding = 4) readonly buffer _ReceiverData { GPUReceiverData receivers[]; };
layout(set = 0, binding = 5) buffer _ReceiverRaycastResult { GPUReceiverRaycastResult results[]; };
layout(set = 0, binding = 6, scalar) readonly buffer _ReceiverProbeWeights { float weights[]; };
layout(set = 0, binding = 7, scalar) readonly buffer _ClusterProbes { int probes[]; };

layout(push_constant) uniform _PushConstantRay { int probeCount; int batchOffset; int receiverOffset; };
const float PI  = 3.14159265358979323846264;

float random (vec2 st)
{
    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

vec3 hemiSpherePointCos(float u, float v, vec3 normal)
{
    float a = 6.2831853 * v;
    u = 2.0*u - 1.0;
    return normalize(normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u));
}

uint wang_hash(inout uint seed) {
    seed = (seed ^ 61) ^ (seed >> 16);
    seed *= 9;
    seed = seed ^ (seed >> 4);
    seed *= 0x27d4eb2d;
    seed = seed ^ (seed >> 15);
    return seed;
}

float random_float(inout uint state)
{
    return (wang_hash(state) & 0xFFFFFF) / 16777216.0f;
}

float random_float_between(inout uint state, float min, float max) {
    return min + (max - min) * random_float(state);
}

vec3 random_unit_vector(inout uint state) {
    float a = random_float_between(state, 0.0, 2.0 * PI);
    float z = random_float_between(state, -1.0, 1.0);
    float r = sqrt(1.0 - z * z);
    return vec3(r * cos(a), r * sin(a), z);
}

void main()
{
    uint receiverId = batchOffset + gl_LaunchIDEXT.x;
    vec3 receiverPos = receivers[receiverId].pos;
    vec3 receiverNormal = normalize(receivers[receiverId].normal.xyz);

    float _u = random(vec2(receiverId, gl_LaunchIDEXT.y * 2));
    float _v = random(vec2(receiverId, gl_LaunchIDEXT.y * 2 + 1));

    uint random_state = (gl_LaunchIDEXT.x * 1973 + 9277  * gl_LaunchIDEXT.y + receiverId * 26699) | 1;

    vec3 direction = normalize(receiverNormal + random_unit_vector(random_state));
    //vec3 direction = normalize(hemiSpherePointCos(_u, _v, receiverNormal));

    uint  rayFlags = gl_RayFlagsOpaqueEXT;
    float tMin     = 0.0001;
    float tMax     = 10000.0;
    
    vec3 raystartPos = receiverPos.xyz + receiverNormal * abs(receiverPos.xyz * 0.0000002);
    
    //trace tangential rays to detect backface hitting. Push texel center outside using both hit face normal and ray direction.



    traceRayEXT(topLevelAS,     // acceleration structure
                rayFlags,       // rayFlags
                0xFF,           // cullMask
                0,              // sbtRecordOffset
                0,              // sbtRecordStride
                0,              // missIndex
                raystartPos,     // ray origin
                tMin,           // ray min range
                direction.xyz,  // ray direction
                tMax,           // ray max range
                0               // payload (location = 0)
    );

    //if(receiverId == 240 && payload.objectId != -1) {
    //    debugPrintfEXT("%f %d %d\n", distance(receiverPos.xyz + receiverNormal * 0.1, payload.pos), payload.objectId, receivers[receiverId].objectId);
    //}

    vec3 hitNormal = payload.normal;
    vec3 hitLocation = payload.pos;
    int hitObjectId = payload.objectId;

    for(int a = 0; a < probeCount; a++) {
        int probeIndex = probes[a];
        //if(receiverId == 35 && gl_LaunchIDEXT.y == 0) {
        //    debugPrintfEXT("Probes: %d\n", probeIndex);
        //}

        if(distance(raystartPos, hitLocation) > 0.001) {
            int visibility = 0;
            vec4 probePos = probeLocations[probeIndex];
            vec3 probeDir = direction.xyz;

            if(hitObjectId == -1) {
                //ray is a miss
                //trace a ray from the probe with the same direction
                //traceRayEXT(topLevelAS,     // acceleration structure
                //        rayFlags,       // rayFlags
                //        0xFF,           // cullMask
                //        0,              // sbtRecordOffset
                //        0,              // sbtRecordStride
                //        0,              // missIndex
                //        probePos.xyz,     // ray origin
                //        tMin,           // ray min range
                //        direction.xyz,  // ray direction
                //        tMax,           // ray max range
                //        0               // payload (location = 0)
                //);
                ////???
                //if(payload.objectId == -1) {
                //    //visibility = 1;
                //}
            }
            else {
                //ray hit a location
                //trace a ray from the probe towards hit location
                probeDir = normalize(hitLocation - probePos.xyz);

                traceRayEXT(topLevelAS,     // acceleration structure
                        rayFlags,       // rayFlags
                        0xFF,           // cullMask
                        0,              // sbtRecordOffset
                        0,              // sbtRecordStride
                        0,              // missIndex
                        probePos.xyz,     // ray origin
                        tMin,           // ray min range
                        probeDir,  // ray direction
                        tMax,           // ray max range
                        0               // payload (location = 0)
                );
                if(payload.objectId == hitObjectId && distance(hitLocation, payload.pos) < 0.001 /* && dot(hitNormal, direction) < 0 && dot(payload.normal, probeDir) < 0 && dot(hitNormal, payload.normal) > 0*/) {
                    visibility = 1;
                }
            }

            results[a + gl_LaunchIDEXT.y * probeCount + gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y * probeCount].dir = probeDir;
            results[a + gl_LaunchIDEXT.y * probeCount + gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y * probeCount].visibility = visibility;
        }
        else {
            results[a + gl_LaunchIDEXT.y * probeCount + gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y * probeCount].dir = vec3(0);
            results[a + gl_LaunchIDEXT.y * probeCount + gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y * probeCount].visibility = 0;
        }
    }
}